
# Define XDG directories
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_DATA_HOME="$HOME/.local/share"


HISTFILE="$HOME/.zsh_history"
HISTSIZE=10000000
SAVEHIST=10000000

HISTORY_IGNORE="(ls|cd|pwd|exit|cd|history|mount|man)*"

# Execute neofetch
fastfetch

(( ${+commands[direnv]} )) && emulate zsh -c "$(direnv export zsh)"

# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Path to your oh-my-zsh installation.
export ZSH=~/.oh-my-zsh
DISABLE_AUTO_UPDATE="true"

if [[ "$TERM_PROGRAM" == "vscode" ]]; then
  ITERM_SHELL_INTEGRATION_INSTALLED="Yes"
fi

# Set name of the theme to load.
# Look in ~/.oh-my-zsh/themes/
# Optionally, if you set this to "random", it'll load a random theme each
# time that oh-my-zsh is loaded.
ZSH_THEME="powerlevel10k/powerlevel10k"

# Enable vim key bindings
bindkey -v

# Set default user for prompt
DEFAULT_USER=`whoami`

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
COMPLETION_WAITING_DOTS="true"

################################################################################
# Oh My Zsh Plugins
################################################################################

plugins=(
  1password
  aws
  branch
  brew
  dash
  docker
  dotenv
  extract
  forklift
  fzf
  gcloud
  gem
  gh
#  git
  git-extras
  git-flow
  gitignore
  golang
  history
  jsontools
  kubectl
  kubectx
  macos
  marked2
  pip
  pipenv
  pre-commit
  python
  shrink-path
  ssh-agent
  sublime
  sudo
  terraform
  tmux
  urltools
  vagrant
  zsh-autosuggestions
  )






# User configuration

export PATH=$PATH:~/bin:~/.cargo/bin
source $ZSH/oh-my-zsh.sh

# You may need to manually set your language environment
export LANG=en_US.UTF-8
export EDITOR=nvim

################################################################################
# History Options
# https://martinheinz.dev/blog/110
################################################################################

setopt EXTENDED_HISTORY         # Write the history file in the ':start:elapsed;command' format.
setopt INC_APPEND_HISTORY       # Write to the history file immediately, not when the shell exits.
setopt SHARE_HISTORY            # Share history between all sessions.
setopt HIST_IGNORE_DUPS         # Do not record an event that was just recorded again.
setopt HIST_IGNORE_ALL_DUPS     # Delete an old recorded event if a new event is a duplicate.
setopt HIST_IGNORE_SPACE        # Do not record an event starting with a space.
setopt HIST_SAVE_NO_DUPS        # Do not write a duplicate event to the history file.
setopt HIST_VERIFY              # Do not execute immediately upon history expansion.
setopt APPEND_HISTORY           # append to history file (Default)
setopt HIST_NO_STORE            # Don't store history commands
setopt HIST_REDUCE_BLANKS       # Remove superfluous blanks from each command line being added to the history.
# setopt HIST_STAMPS="yyyy-mm-dd" (Non Supported)
################################################################################

# ostype returns the lowercase OS name
ostype() {
    echo ${(L):-$(uname)}
}

# os_detect export the PLATFORM variable as you see fit
os_detect() {
    export PLATFORM
    case "$(ostype)" in
        *'linux'*)  PLATFORM='linux'   ;;
        *'darwin'*) PLATFORM='osx'     ;;
        *'bsd'*)    PLATFORM='bsd'     ;;
        *)          PLATFORM='unknown' ;;
    esac
}

# is_osx returns true if running OS is Macintosh
is_osx() {
    os_detect
    if [[ $PLATFORM == "osx" ]]; then
        return 0
    else
        return 1
    fi
}
alias is_mac=is_osx

# is_linux returns true if running OS is GNU/Linux
is_linux() {
    os_detect
    if [[ $PLATFORM == "linux" ]]; then
        return 0
    else
        return 1
    fi
}

# is_bsd returns true if running OS is FreeBSD
is_bsd() {
    os_detect
    if [[ $PLATFORM == "bsd" ]]; then
        return 0
    else
        return 1
    fi
}

# get_os returns OS name of the PLATFORM that is running
get_os() {
    local os
    for os in osx linux bsd; do
        if is_$os; then
            echo $os
        fi
    done
}


function swap()
{ # Swap 2 filenames around, if they exist (from Uzi's bashrc).
    local TMPFILE=tmp.$$

    [ $# -ne 2 ] && echo "swap: 2 arguments needed" && return 1
    [ ! -e $1 ] && echo "swap: $1 does not exist" && return 1
    [ ! -e $2 ] && echo "swap: $2 does not exist" && return 1

    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}

function extract()      # Handy Extract Program
{
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xvjf $1     ;;
            *.tar.gz)    tar xvzf $1     ;;
            *.bz2)       bunzip2 $1      ;;
            *.rar)       unrar x $1      ;;
            *.gz)        gunzip $1       ;;
            *.tar)       tar xvf $1      ;;
            *.tbz2)      tar xvjf $1     ;;
            *.tgz)       tar xvzf $1     ;;
            *.zip)       unzip $1        ;;
            *.Z)         uncompress $1   ;;
            *.7z)        7z x $1         ;;
            *)           echo "'$1' cannot be extracted via >extract<" ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

# Creates an archive (*.tar.gz) from given directory.
function maketar() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }

# Create a ZIP archive of a file or folder.
function makezip() { zip -r "${1%%/}.zip" "$1" ; }

# Make your directories and files access rights sane.
function sanitize() { chmod -R u=rwX,g=rX,o= "$@" ;}

SSHAGENT=/usr/bin/ssh-agent
SSHAGENTARGS="-s"
if [ -z "$SSH_AUTH_SOCK" -a -x "$SSHAGENT" ]; then
    eval `$SSHAGENT $SSHAGENTARGS`
    trap "kill $SSH_AGENT_PID" 0
fi

# if [ -z "$TMUX" ]; then
#     # we're not in a tmux session

#     if [ ! -z "$SSH_TTY" ]; then
#         # We logged in via SSH

#         # if ssh auth variable is missing
#         if [ -z "$SSH_AUTH_SOCK" ]; then
#             export SSH_AUTH_SOCK="$HOME/.ssh/.auth_socket"
#         fi

#         # if socket is available create the new auth session
#         if [ ! -S "$SSH_AUTH_SOCK" ]; then
#             `ssh-agent -a $SSH_AUTH_SOCK` &gt; /dev/null 2>&1
#             echo $SSH_AGENT_PID &gt; $HOME/.ssh/.auth_pid
#         fi

#         # if agent isn't defined, recreate it from pid file
#         if [ -z $SSH_AGENT_PID ]; then
#             export SSH_AGENT_PID=`cat $HOME/.ssh/.auth_pid`
#         fi

#         # Add all default keys to ssh auth
#         ssh-add 2>/dev/null

#     fi
# fi




# Source alias file
source ~/.zsh_aliases

if [[ $PLATFORM == 'osx' ]]; then

  # Requires coreutils from brew
  PATH="/usr/local/opt/coreutils/libexec/gnubin:$PATH"
  MANPATH="/usr/local/opt/coreutils/libexec/gnuman:$MANPATH"
  {{ if eq .appearance  "light" -}}
  export LS_COLORS="$(vivid generate catppuccin-latte)"
  {{- else -}}
  export LS_COLORS="$(vivid generate catppuccin-mocha)"
  {{- end }}

fi

###############################################################################
# http://brettterpstra.com/2019/01/15/stuff-ive-made-and-actually-use/
###############################################################################

###############################################################################

# iTerm2 Shell Integration
if [[ $TERM_PROGRAM != "WarpTerminal" ]]; then
    ##### WHAT YOU WANT TO DISABLE FOR WARP - BELOW
    #
    test -e ${HOME}/.iterm2_shell_integration.bash && source ${HOME}/.iterm2_shell_integration.bash
    #
    ###### WHAT YOU WANT TO DISABLE FOR WARP - ABOVE
fi

if [[ $TERM_PROGRAM != "WarpTerminal" ]]; then
    ##### WHAT YOU WANT TO DISABLE FOR WARP - BELOW
    #
    #    # POWERLEVEL10K or Other Unsupported Custom Prompt Code
    #
    #    ##### WHAT YOU WANT TO DISABLE FOR WARP - ABOVE
fi

[[ "$TERM_PROGRAM" == "vscode" ]] && . "$(code --locate-shell-integration-path zsh)"



alias more='less'
export LESS='-R'
# https://github.com/wofr06/lesspipe
export LESSOPEN="|/usr/local/bin/lesspipe.sh %s"

# LESS man page colors (makes Man pages more readable).
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'



autoload -U +X bashcompinit && bashcompinit

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# tmux-window-name() {
#   if [[ -z "$TMUX" ]] || [[ -z "$TMUX_PLUGIN_MANAGER_PATH" ]]; then
#     return
#   fi
#   ($TMUX_PLUGIN_MANAGER_PATH/tmux-window-name/scripts/rename_session_windows.py >/dev/null 2>&1 || true &)
# }


if [[ $PLATFORM == 'osx' ]]; then
  source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi
# https://github.com/athityakumar/colorls
# source $(dirname $(gem which colorls))/tab_complete.sh

# fzf https://www.youtube.com/watch?v=mmqDYw9C30I&t=15s
eval "$(fzf --zsh)"
source ~/fzf-git/fzf-git.sh

# -- Use fd instead of fzf --
export FZF_DEFAULT_OPTS=" \
--color=bg+:#313244,bg:#1E1E2E,spinner:#F5E0DC,hl:#F38BA8 \
--color=fg:#CDD6F4,header:#F38BA8,info:#CBA6F7,pointer:#F5E0DC \
--color=marker:#B4BEFE,fg+:#CDD6F4,prompt:#CBA6F7,hl+:#F38BA8 \
--color=selected-bg:#45475A \
--color=border:#6C7086,label:#CDD6F4"
export FZF_DEFAULT_COMMAND="fd --hidden --strip-cwd-prefix --exclude .git"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND="fd --type=d --hidden --strip-cwd-prefix --exclude .git"

# Use fd (https://github.com/sharkdp/fd) for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversl
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
  fd --hidden --exclude .git . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
  fd --type=d --hidden --exclude .git . "$1"
}


show_file_or_dir_preview="if [ -d {} ]; then eza --tree --color=always {} | head -200; else bat -n --color=always --line-range :500 {}; fi"

export FZF_CTRL_T_OPTS="--preview '$show_file_or_dir_preview'"
export FZF_ALT_C_OPTS="--preview 'eza --tree --color=always {} | head -200'"

# Advanced customization of fzf options via _fzf_comprun function
# - The first argument to the function is the name of the command.
# - You should make sure to pass the rest of the arguments to fzf.
_fzf_comprun() {
  local command=$1
  shift

  case "$command" in
    cd)           fzf --preview 'eza --tree --color=always {} | head -200' "$@" ;;
    export|unset) fzf --preview "eval 'echo ${}'"         "$@" ;;
    ssh)          fzf --preview 'dig {}'                   "$@" ;;
    *)            fzf --preview "$show_file_or_dir_preview" "$@" ;;
  esac
}
# GO setup
export GOPATH=$HOME/go
export GOBIN=$GOPATH/bin

if [[ $PLATFORM == 'osx' ]]; then
  export GOROOT="$(brew --prefix golang)/libexec"
fi

# direnv
(( ${+commands[direnv]} )) && emulate zsh -c "$(direnv hook zsh)"
export DIRENV_LOG_FORMAT=$'\033[2mdirenv: %s\033[0m'

# bat
export MANPAGER="sh -c 'col -bx | bat -l man -p'"

# Johnny Decimal

cdj() {
  # Update with your document root folder
  pushd ~/Documents/*/*/${1}*
}

# Enable grc for commands that support it
[[ -s "/opt/homebrew/etc/grc.zsh" ]] && source /opt/homebrew/etc/grc.zsh


# ################################################################################
# # Ruby
# ################################################################################
if [[ $PLATFORM == 'osx' ]]; then
  export RUBY_CONFIGURE_OPTS="--with-openssl-dir=$(brew --prefix openssl@3)"
fi
eval "$(rbenv init -)"

# ################################################################################
# # Node
# ################################################################################
# export NVM_DIR="$HOME/.nvm"
#   [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \. "/opt/homebrew/opt/nvm/nvm.sh"  # This loads nvm
#   [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"
#
# # place this after nvm initialization!
# autoload -U add-zsh-hook
#
# load-nvmrc() {
#   local nvmrc_path
#   nvmrc_path="$(nvm_find_nvmrc)"
#
#   if [ -n "$nvmrc_path" ]; then
#     local nvmrc_node_version
#     nvmrc_node_version=$(nvm version "$(cat "${nvmrc_path}")")
#
#     if [ "$nvmrc_node_version" = "N/A" ]; then
#       nvm install
#     elif [ "$nvmrc_node_version" != "$(nvm version)" ]; then
#       nvm use
#     fi
#   elif [ -n "$(PWD=$OLDPWD nvm_find_nvmrc)" ] && [ "$(nvm version)" != "$(nvm version default)" ]; then
#     echo "Reverting to nvm default version"
#     nvm use default
#   fi
# }
#
# add-zsh-hook chpwd load-nvmrc
# load-nvmrc

# ##############################################################################

export cdj

# Install Homebrew Casks in user's Applications directory
export HOMEBREW_CASK_OPTS="--appdir=~/Applications"

eval "$(zoxide init zsh)"

# Set theme
{{ if eq .appearance  "light" -}}
source ~/.zsh/catppuccin_latte-zsh-syntax-highlighting.zsh
{{- else -}}
source ~/.zsh/catppuccin_mocha-zsh-syntax-highlighting.zsh
{{- end }}

# ################################################################################
# Yazi
# ################################################################################
function y() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
	yazi "$@" --cwd-file="$tmp"
	IFS= read -r -d '' cwd < "$tmp"
	[ -n "$cwd" ] && [ "$cwd" != "$PWD" ] && builtin cd -- "$cwd"
	/bin/rm -f -- "$tmp"
}

source ~/.config/op/plugins.sh
source ~/.zshrc_local

export PATH="/opt/homebrew/bin:$PATH"
