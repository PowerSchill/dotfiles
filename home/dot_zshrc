# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Path to your oh-my-zsh installation.
export ZSH=~/.oh-my-zsh
DISABLE_AUTO_UPDATE="true"

# Set name of the theme to load.
# Look in ~/.oh-my-zsh/themes/
# Optionally, if you set this to "random", it'll load a random theme each
# time that oh-my-zsh is loaded.
ZSH_THEME="powerlevel10k/powerlevel10k"

# Set default user for prompt
DEFAULT_USER=`whoami`

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
COMPLETION_WAITING_DOTS="true"

# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(
  # knife
  brew
  colored-man-pages
  dash
  extract
  gcloud
  gem
  git
  git-extras
  git-flow
  gitignore
  history
  jsontools
  kubectl
  macos
  marked2
  shrink-path
  ssh-agent
  sublime
  sudo
  terraform
  tmux
  urltools
  vagrant
  zsh-autosuggestions
  z
  )

# User configuration

PATH=$PATH:~/bin
# PATH=$PATH:/Users/ms185570/.chefdk/gem/ruby/2.5.0/bin
export PATH

source $ZSH/oh-my-zsh.sh

# You may need to manually set your language environment
export LANG=en_US.UTF-8
export EDITOR=vim

# ssh
# export SSH_KEY_PATH="~/.ssh/dsa_id"


# ostype returns the lowercase OS name
ostype() {
    echo ${(L):-$(uname)}
}


# os_detect export the PLATFORM variable as you see fit
os_detect() {
    export PLATFORM
    case "$(ostype)" in
        *'linux'*)  PLATFORM='linux'   ;;
        *'darwin'*) PLATFORM='osx'     ;;
        *'bsd'*)    PLATFORM='bsd'     ;;
        *)          PLATFORM='unknown' ;;
    esac
}

# is_osx returns true if running OS is Macintosh
is_osx() {
    os_detect
    if [[ $PLATFORM == "osx" ]]; then
        return 0
    else
        return 1
    fi
}
alias is_mac=is_osx

# is_linux returns true if running OS is GNU/Linux
is_linux() {
    os_detect
    if [[ $PLATFORM == "linux" ]]; then
        return 0
    else
        return 1
    fi
}

# is_bsd returns true if running OS is FreeBSD
is_bsd() {
    os_detect
    if [[ $PLATFORM == "bsd" ]]; then
        return 0
    else
        return 1
    fi
}

# get_os returns OS name of the PLATFORM that is running
get_os() {
    local os
    for os in osx linux bsd; do
        if is_$os; then
            echo $os
        fi
    done
}




function swap()
{ # Swap 2 filenames around, if they exist (from Uzi's bashrc).
    local TMPFILE=tmp.$$

    [ $# -ne 2 ] && echo "swap: 2 arguments needed" && return 1
    [ ! -e $1 ] && echo "swap: $1 does not exist" && return 1
    [ ! -e $2 ] && echo "swap: $2 does not exist" && return 1

    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}

function extract()      # Handy Extract Program
{
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xvjf $1     ;;
            *.tar.gz)    tar xvzf $1     ;;
            *.bz2)       bunzip2 $1      ;;
            *.rar)       unrar x $1      ;;
            *.gz)        gunzip $1       ;;
            *.tar)       tar xvf $1      ;;
            *.tbz2)      tar xvjf $1     ;;
            *.tgz)       tar xvzf $1     ;;
            *.zip)       unzip $1        ;;
            *.Z)         uncompress $1   ;;
            *.7z)        7z x $1         ;;
            *)           echo "'$1' cannot be extracted via >extract<" ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

# Creates an archive (*.tar.gz) from given directory.
function maketar() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }

# Create a ZIP archive of a file or folder.
function makezip() { zip -r "${1%%/}.zip" "$1" ; }

# Make your directories and files access rights sane.
function sanitize() { chmod -R u=rwX,g=rX,o= "$@" ;}

SSHAGENT=/usr/bin/ssh-agent
SSHAGENTARGS="-s"
if [ -z "$SSH_AUTH_SOCK" -a -x "$SSHAGENT" ]; then
    eval `$SSHAGENT $SSHAGENTARGS`
    trap "kill $SSH_AGENT_PID" 0
fi

# Bash history settings
export HISTFILESIZE=10000
export HISTSIZE=10000
export HISTCONTROL=ignoreboth
export HISTIGNORE="reboot:shutdown *:ls:pwd:exit:mount:man *:history"
export HISTTIMEFORMAT='%F %T '


# if [ -z "$TMUX" ]; then
#     # we're not in a tmux session

#     if [ ! -z "$SSH_TTY" ]; then
#         # We logged in via SSH

#         # if ssh auth variable is missing
#         if [ -z "$SSH_AUTH_SOCK" ]; then
#             export SSH_AUTH_SOCK="$HOME/.ssh/.auth_socket"
#         fi

#         # if socket is available create the new auth session
#         if [ ! -S "$SSH_AUTH_SOCK" ]; then
#             `ssh-agent -a $SSH_AUTH_SOCK` &gt; /dev/null 2>&1
#             echo $SSH_AGENT_PID &gt; $HOME/.ssh/.auth_pid
#         fi

#         # if agent isn't defined, recreate it from pid file
#         if [ -z $SSH_AGENT_PID ]; then
#             export SSH_AGENT_PID=`cat $HOME/.ssh/.auth_pid`
#         fi

#         # Add all default keys to ssh auth
#         ssh-add 2>/dev/null

#     fi
# fi


ZSH_TMUX_AUTOSTART=true
ZSH_TMUX_AUTOCONNECT=true

# Source alias file
source ~/.zsh_aliases

if [[ $PLATFORM == 'osx' ]]; then

  # Requires coreutils from brew
  PATH="/usr/local/opt/coreutils/libexec/gnubin:$PATH"
  MANPATH="/usr/local/opt/coreutils/libexec/gnuman:$MANPATH"
  test -e ~/.dir_colors && eval `dircolors -b ~/.dir_colors`

fi

###############################################################################
# http://brettterpstra.com/2019/01/15/stuff-ive-made-and-actually-use/
###############################################################################

###############################################################################

# iTerm2 Shell Integration
test -e ${HOME}/.iterm2_shell_integration.bash && source ${HOME}/.iterm2_shell_integration.bash

# Adds syntax highlighting to less
# export LESSOPEN='|~/.lessfilter %s'

alias more='less'
export LESS='-R'
# https://github.com/wofr06/lesspipe
export LESSOPEN="|/usr/local/bin/lesspipe.sh %s"

# LESS man page colors (makes Man pages more readable).
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'


# Set up Git Town completions
git-town completions bash > /usr/local/etc/bash_completion.d/git-town

# Execute neofetch
neofetch


autoload -U +X bashcompinit && bashcompinit
complete -o nospace -C /usr/local/bin/vault vault

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# Maestral Completion
_maestral_completion() {
    local -a completions
    local -a completions_with_descriptions
    local -a response
    (( ! $+commands[maestral] )) && return 1

    response=("${(@f)$(env COMP_WORDS="${words[*]}" COMP_CWORD=$((CURRENT-1)) _MAESTRAL_COMPLETE=zsh_complete maestral)}")

    for type key descr in ${response}; do
        if [[ "$type" == "plain" ]]; then
            if [[ "$descr" == "_" ]]; then
                completions+=("$key")
            else
                completions_with_descriptions+=("$key":"$descr")
            fi
        elif [[ "$type" == "dir" ]]; then
            _path_files -/
        elif [[ "$type" == "file" ]]; then
            _path_files -f
        fi
    done

    if [ -n "$completions_with_descriptions" ]; then
        _describe -V unsorted completions_with_descriptions -U
    fi

    if [ -n "$completions" ]; then
        compadd -U -V unsorted -a completions
    fi
}

eval "$(rbenv init -)"

# https://github.com/athityakumar/colorls
source $(dirname $(gem which colorls))/tab_complete.sh

# fzf
source ~/bin/fzf.sh

# direnv
eval "$(direnv hook zsh)"

source ~/.zshrc_local

